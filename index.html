**Updating Form and Filtering Logic**

I’ll add a new “spellSubtype” select field with "Normal" and "Hero" options, and store it in card.spellSubtype. Then, I need to update the filter UI by adding chips for "Spell: Normal" and "Spell: Hero" in the typeFilters or perhaps create a new section for them. For Weapons, I’ll ensure cost and stats row get hidden when the type is Weapon. For spells, I’ll incorporate the new spellSubtype filters and update the render logic. I’ll also include the Mana Dice field for Hero and update all the form processing logic to reflect these changes.
### Updated Definitive Card Designer (with requested changes)

```html
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TCG Card Organizer</title>
<style>
  :root{
    --bg:#0f1724; --card:#071028; --muted:#9aa7b8; --accent:#38bdf8; --panel:#0b1220;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color: #e6eef6;
  }
  body{margin:0;background:linear-gradient(180deg,#071021 0%, #061427 100%);min-height:100vh;padding:24px;}
  .app{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:360px 1fr;gap:20px;}
  .panel{background:var(--card);border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}
  h1{margin:0 0 12px 0;font-size:20px;color:var(--accent);}
  label{display:block;font-size:13px;color:var(--muted);margin-top:12px}
  input[type="text"], input[type="number"], select, textarea{
    width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
    background:var(--panel);color:inherit;font-size:14px;box-sizing:border-box;
  }
  textarea{min-height:90px;resize:vertical;}
  .row{display:flex;gap:8px;}
  .row > *{flex:1;}
  .btn{display:inline-block;padding:8px 12px;border-radius:8px;background:var(--accent);color:#022;cursor:pointer;border:0;font-weight:600;}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:500;}
  .controls{display:flex;gap:8px;align-items:center;margin-top:12px;}
  .filters{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;}
  .chip{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.03);cursor:pointer;border:1px solid rgba(255,255,255,0.03);font-size:13px;color:var(--muted)}
  .chip.active{background:linear-gradient(90deg, rgba(56,189,248,0.12), rgba(56,189,248,0.04));border-color:rgba(56,189,248,0.18);color:var(--accent)}
  .list{padding:12px;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;}
  .cardItem{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);}
  .cardHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .cardTitle{font-weight:700;margin:0;font-size:15px}
  .meta{font-size:12px;color:var(--muted)}
  .tag{display:inline-block;background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:999px;margin-right:6px;font-size:12px;color:var(--muted)}
  .keyword{background:rgba(56,189,248,0.08);color:var(--accent);border:1px solid rgba(56,189,248,0.14)}
  .cardButtons{display:flex;gap:6px;margin-top:10px}
  .small{padding:6px 8px;font-size:13px;border-radius:8px;border:0;cursor:pointer}
  .edit{background:#ffd166;color:#1b1b1b}
  .delete{background:#ef476f;color:#fff}
  footer{margin-top:14px;color:var(--muted);font-size:13px;text-align:center}
  .colorDot{width:12px;height:12px;border-radius:50%;display:inline-block;margin-right:6px;vertical-align:middle;border:1px solid rgba(255,255,255,0.06)}
  .colorRed{background:#ef4444} .colorBlue{background:#3b82f6} .colorGreen{background:#10b981}
  .colorPink{background:#ec4899} .colorBlack{background:#111827} .colorWhite{background:#f3f4f6;border:1px solid #d1d5db}
  .typeBadge{display:inline-block;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,0.03);color:var(--muted);font-size:12px;margin-left:6px}
  .helper{font-size:12px;color:var(--muted);margin-top:6px}
  .hidden{display:none}
  .empty{color:var(--muted);padding:20px;text-align:center}
  @media(max-width:880px){.app{grid-template-columns:1fr;}}
</style>
</head>
<body>
<div class="app">
  <div class="panel" id="editorPanel" aria-label="Card editor">
    <h1>Card Editor</h1>
    <input type="hidden" id="editingId" value="">
    <label>Name</label>
    <input id="name" type="text" placeholder="Card name" />
    <label>Text</label>
    <textarea id="text" placeholder="Card rules, lore, etc."></textarea>
    <label>Tags</label>
    <input id="tags" type="text" placeholder="Comma separated tags e.g. token, removal" />

    <label>Card Type</label>
    <select id="cardType">
      <option value="Unit">Unit</option>
      <option value="Hero">Hero</option>
      <option value="Weapon">Weapon</option>
      <option value="Spell">Spell</option>
    </select>

    <!-- Keywords row (visible for Unit and Hero) -->
    <div id="keywordsRow" class="hidden">
      <label>Keywords</label>
      <input id="keywords" type="text" placeholder="Comma separated keywords e.g. Flying, First strike" />
      <div class="helper">Keywords apply to Heroes and Units only; enter comma separated values.</div>
    </div>

    <div id="costRow">
      <label>Cost</label>
      <input id="cost" type="number" min="0" />
    </div>

    <div id="diceRow" class="hidden">
      <label>Dice</label>
      <input id="dice" type="text" placeholder="e.g. 1d6, 2" />
      <div class="helper">Enter dice value or number used for Hero resolution</div>
    </div>

    <div id="manaDiceRow" class="hidden">
      <label>Mana Dice</label>
      <input id="manaDice" type="text" placeholder="e.g. 1d6, 2" />
      <div class="helper">Mana Dice used for Hero abilities or casting</div>
    </div>

    <div id="flipConditionRow" class="hidden">
      <label>Flip condition</label>
      <input id="flipCondition" type="text" placeholder="Condition to flip" />
    </div>

    <div id="flipTextRow" class="hidden">
      <label>Flip text</label>
      <textarea id="flipText" placeholder="Text that appears after flip"></textarea>
    </div>

    <div id="statsRow">
      <div class="row">
        <div>
          <label>Power</label>
          <input id="power" type="number" min="0" />
        </div>
        <div>
          <label>Health</label>
          <input id="health" type="number" min="0" />
        </div>
      </div>
    </div>

    <div id="spellSpeedRow" class="hidden">
      <label>Spell speed</label>
      <select id="spellSpeed">
        <option value="Slow">Slow</option>
        <option value="Fast">Fast</option>
        <option value="Instant">Instant</option>
      </select>
      <div class="helper">Choose Slow, Fast, or Instant for spells</div>
    </div>

    <div id="spellSubtypeRow" class="hidden">
      <label>Spell subtype</label>
      <select id="spellSubtype">
        <option value="Normal">Normal</option>
        <option value="Hero">Hero</option>
      </select>
      <div class="helper">Normal spells are standard; Hero spells are tied to a Hero and can be organized separately</div>
    </div>

    <label>Color</label>
    <select id="color">
      <option value="Colorless">Colorless</option>
      <option value="Red">Red</option>
      <option value="Blue">Blue</option>
      <option value="Green">Green</option>
      <option value="Pink">Pink</option>
      <option value="White">White</option>
      <option value="Black">Black</option>
    </select>

    <div class="controls">
      <button class="btn" id="saveBtn">Save Card</button>
      <button class="btn secondary" id="clearBtn">Clear Form</button>
      <button class="btn secondary" id="exportBtn">Export JSON</button>
    </div>

    <footer>
      Saved locally in this browser. Use Export JSON to download all cards.
    </footer>
  </div>

  <div class="panel" id="libraryPanel" aria-label="Card library">
    <h1>Library</h1>

    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <input id="search" type="text" placeholder="Search by name, tag, or type" style="flex:1;padding:8px;border-radius:8px;background:var(--panel);border:1px solid rgba(255,255,255,0.03);color:inherit" />
      <select id="sort" style="padding:8px;border-radius:8px;background:var(--panel);border:1px solid rgba(255,255,255,0.03);color:inherit">
        <option value="newest">Newest</option>
        <option value="name">Name A→Z</option>
        <option value="cost">Cost low→high</option>
      </select>
    </div>

    <div class="filters" id="colorFilters">
      <div class="chip active" data-color="All">All</div>
      <div class="chip" data-color="Red"><span class="colorDot colorRed"></span>Red</div>
      <div class="chip" data-color="Blue"><span class="colorDot colorBlue"></span>Blue</div>
      <div class="chip" data-color="Green"><span class="colorDot colorGreen"></span>Green</div>
      <div class="chip" data-color="Pink"><span class="colorDot colorPink"></span>Pink</div>
      <div class="chip" data-color="White"><span class="colorDot colorWhite"></span>White</div>
      <div class="chip" data-color="Black"><span class="colorDot colorBlack"></span>Black</div>
      <div class="chip" data-color="Colorless">Colorless</div>
    </div>

    <div class="filters" id="typeFilters" aria-label="Type filters" style="margin-bottom:12px">
      <div class="chip active" data-type="All">All types</div>
      <div class="chip" data-type="Unit">Unit</div>
      <div class="chip" data-type="Hero">Hero</div>
      <div class="chip" data-type="Weapon">Weapon</div>
      <div class="chip" data-type="Spell">Spell</div>
    </div>

    <div class="filters" id="spellSubtypeFilters" style="margin-bottom:12px">
      <div class="chip active" data-spell="All">All spells</div>
      <div class="chip" data-spell="Normal">Normal spells</div>
      <div class="chip" data-spell="Hero">Hero spells</div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">
      <input id="importFile" type="file" accept=".json,application/json" style="flex:1;padding:8px;border-radius:8px;background:var(--panel);border:1px solid rgba(255,255,255,0.03);color:inherit" />
      <button id="importBtn" class="btn secondary" title="Import selected JSON file">Import File</button>
      <button id="removeDupesBtn" class="btn secondary" title="Remove exact duplicate cards">Remove duplicates</button>
    </div>

    <div id="listArea">
      <div class="list" id="cardList"></div>
      <div id="empty" class="empty" style="display:none">No cards yet. Create one using the editor on the left.</div>
    </div>
  </div>
</div>

<!-- Modal-like simple confirm -->
<div id="confirm" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(2,6,23,0.6)">
  <div style="background:#071028;padding:16px;border-radius:10px;max-width:400px;width:90%">
    <div style="margin-bottom:12px;color:var(--muted)">Delete this card permanently?</div>
    <div style="text-align:right">
      <button id="cancelDelete" class="btn secondary" style="margin-right:8px">Cancel</button>
      <button id="confirmDelete" class="btn" style="background:#ef476f">Delete</button>
    </div>
  </div>
</div>

<script>
(function(){
  const LS_KEY = 'tcg_cards_v2';
  const formEls = {
    id: document.getElementById('editingId'),
    name: document.getElementById('name'),
    text: document.getElementById('text'),
    tags: document.getElementById('tags'),
    keywords: document.getElementById('keywords'),
    cost: document.getElementById('cost'),
    power: document.getElementById('power'),
    health: document.getElementById('health'),
    color: document.getElementById('color'),
    type: document.getElementById('cardType'),
    dice: document.getElementById('dice'),
    manaDice: document.getElementById('manaDice'),
    flipCondition: document.getElementById('flipCondition'),
    flipText: document.getElementById('flipText'),
    spellSpeed: document.getElementById('spellSpeed'),
    spellSubtype: document.getElementById('spellSubtype'),
  };
  const rows = {
    keywordsRow: document.getElementById('keywordsRow'),
    costRow: document.getElementById('costRow'),
    statsRow: document.getElementById('statsRow'),
    diceRow: document.getElementById('diceRow'),
    manaDiceRow: document.getElementById('manaDiceRow'),
    flipConditionRow: document.getElementById('flipConditionRow'),
    flipTextRow: document.getElementById('flipTextRow'),
    spellSpeedRow: document.getElementById('spellSpeedRow'),
    spellSubtypeRow: document.getElementById('spellSubtypeRow'),
  };
  const saveBtn = document.getElementById('saveBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importFile = document.getElementById('importFile');
  const importBtn = document.getElementById('importBtn');
  const removeDupesBtn = document.getElementById('removeDupesBtn');
  const cardList = document.getElementById('cardList');
  const empty = document.getElementById('empty');
  const searchInput = document.getElementById('search');
  const sortSelect = document.getElementById('sort');
  const colorFilters = document.getElementById('colorFilters');
  const typeFilters = document.getElementById('typeFilters');
  const spellSubtypeFilters = document.getElementById('spellSubtypeFilters');
  const confirmEl = document.getElementById('confirm');
  const cancelDelete = document.getElementById('cancelDelete');
  const confirmDelete = document.getElementById('confirmDelete');

  let cards = loadCards();
  let activeColor = 'All';
  let activeType = 'All';
  let activeSpellSubtype = 'All';
  let toDeleteId = null;
  function uid() {
    return 'c_'+Date.now().toString(36)+'_'+Math.random().toString(36).slice(2,8);
  }

  function loadCards(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      return raw ? JSON.parse(raw) : [];
    }catch(e){
      console.error(e);
      return [];
    }
  }
  function saveAll(){
    localStorage.setItem(LS_KEY, JSON.stringify(cards));
    renderList();
  }

  function clearForm(){
    formEls.id.value = '';
    formEls.name.value = '';
    formEls.text.value = '';
    formEls.tags.value = '';
    formEls.keywords.value = '';
    formEls.cost.value = '';
    formEls.power.value = '';
    formEls.health.value = '';
    formEls.color.value = 'Colorless';
    formEls.type.value = 'Unit';
    formEls.dice.value = '';
    formEls.manaDice.value = '';
    formEls.flipCondition.value = '';
    formEls.flipText.value = '';
    formEls.spellSpeed.value = 'Slow';
    formEls.spellSubtype.value = 'Normal';
    saveBtn.textContent = 'Save Card';
    updateVisibleFields();
    window.scrollTo({top:0,behavior:'smooth'});
  }

  function fillForm(card){
    formEls.id.value = card.id;
    formEls.name.value = card.name;
    formEls.text.value = card.text;
    formEls.tags.value = (card.tags||[]).join(', ');
    formEls.keywords.value = (card.keywords||[]).join(', ');
    formEls.cost.value = card.cost == null ? '' : card.cost;
    formEls.power.value = card.power == null ? '' : card.power;
    formEls.health.value = card.health == null ? '' : card.health;
    formEls.color.value = card.color || 'Colorless';
    formEls.type.value = card.type || 'Unit';
    formEls.dice.value = card.dice || '';
    formEls.manaDice.value = card.manaDice || '';
    formEls.flipCondition.value = card.flipCondition || '';
    formEls.flipText.value = card.flipText || '';
    formEls.spellSpeed.value = card.spellSpeed || 'Slow';
    formEls.spellSubtype.value = card.spellSubtype || 'Normal';
    saveBtn.textContent = 'Update Card';
    updateVisibleFields();
    window.scrollTo({top:0,behavior:'smooth'});
  }

  function updateVisibleFields(){
    const t = formEls.type.value;
    // show keywords only for Unit and Hero
    if(t === 'Unit' || t === 'Hero'){
      rows.keywordsRow.classList.remove('hidden');
    } else {
      rows.keywordsRow.classList.add('hidden');
    }

    // Spell specific rows
    if(t === 'Spell'){
      rows.costRow.classList.remove('hidden');
      rows.statsRow.classList.add('hidden');
      rows.diceRow.classList.add('hidden');
      rows.manaDiceRow.classList.add('hidden');
      rows.flipConditionRow.classList.add('hidden');
      rows.flipTextRow.classList.add('hidden');
      rows.spellSpeedRow.classList.remove('hidden');
      rows.spellSubtypeRow.classList.remove('hidden');
    } else if(t === 'Hero'){
      rows.costRow.classList.add('hidden');
      rows.statsRow.classList.remove('hidden');
      rows.diceRow.classList.remove('hidden');
      rows.manaDiceRow.classList.remove('hidden');
      rows.flipConditionRow.classList.remove('hidden');
      rows.flipTextRow.classList.remove('hidden');
      rows.spellSpeedRow.classList.add('hidden');
      rows.spellSubtypeRow.classList.add('hidden');
    } else if(t === 'Weapon'){
      // For weapons: remove cost, power, health sections from editor view
      rows.costRow.classList.add('hidden');
      rows.statsRow.classList.add('hidden');
      rows.diceRow.classList.add('hidden');
      rows.manaDiceRow.classList.add('hidden');
      rows.flipConditionRow.classList.add('hidden');
      rows.flipTextRow.classList.add('hidden');
      rows.spellSpeedRow.classList.add('hidden');
      rows.spellSubtypeRow.classList.add('hidden');
    } else {
      // Unit or other
      rows.costRow.classList.remove('hidden');
      rows.statsRow.classList.remove('hidden');
      rows.diceRow.classList.add('hidden');
      rows.manaDiceRow.classList.add('hidden');
      rows.flipConditionRow.classList.add('hidden');
      rows.flipTextRow.classList.add('hidden');
      rows.spellSpeedRow.classList.add('hidden');
      rows.spellSubtypeRow.classList.add('hidden');
    }
  }

  function addOrUpdate(){
    const data = {
      id: formEls.id.value || uid(),
      name: formEls.name.value.trim(),
      text: formEls.text.value.trim(),
      tags: formEls.tags.value.split(',').map(t=>t.trim()).filter(t=>t),
      keywords: formEls.keywords.value.split(',').map(k=>k.trim()).filter(k=>k),
      cost: formEls.cost.value === '' ? null : Number(formEls.cost.value),
      power: formEls.power.value === '' ? null : Number(formEls.power.value),
      health: formEls.health.value === '' ? null : Number(formEls.health.value),
      color: formEls.color.value || 'Colorless',
      type: formEls.type.value || 'Unit',
      dice: formEls.dice.value || null,
      manaDice: formEls.manaDice.value || null,
      flipCondition: formEls.flipCondition.value || null,
      flipText: formEls.flipText.value || null,
      spellSpeed: formEls.spellSpeed.value || null,
      spellSubtype: formEls.spellSubtype ? formEls.spellSubtype.value : 'Normal',
      updated: Date.now()
    };
    if(!data.name){
      alert('Please give the card a name.');
      return;
    }
    // Normalize fields depending on type
    if(data.type === 'Spell'){
      // Spells keep cost (for some systems) but remove unit stats
      data.power = null;
      data.health = null;
      data.dice = null;
      data.flipCondition = null;
      data.flipText = null;
      data.keywords = []; // keywords not used for spells
      if(!data.spellSubtype) data.spellSubtype = 'Normal';
    } else if(data.type === 'Hero'){
      // Heroes use manaDice and dice, no cost
      data.cost = null;
      // keep keywords
    } else if(data.type === 'Weapon'){
      // Weapons: remove cost, power, health
      data.cost = null;
      data.power = null;
      data.health = null;
      data.dice = null;
      data.flipCondition = null;
      data.flipText = null;
      data.manaDice = null;
      data.spellSpeed = null;
      data.spellSubtype = null;
      // keywords cleared for non-Unit types except Hero above
      data.keywords = [];
    } else {
      // Unit/other: keep keywords for Unit, clear for others
      if(data.type !== 'Unit'){
        data.keywords = [];
      }
      data.spellSubtype = null;
    }
    const existingIndex = cards.findIndex(c=>c.id === data.id);
    if(existingIndex >= 0){
      cards[existingIndex] = Object.assign({}, cards[existingIndex], data);
    } else {
      cards.unshift(data);
    }
    saveAll();
    clearForm();
  }

  // create a stable normalized key for a card's characteristics
  function cardSignature(card){
    // include only the defining characteristics (exclude id and updated)
    const obj = {
      name: (card.name || '').trim(),
      text: (card.text || '').trim(),
      tags: Array.isArray(card.tags) ? card.tags.slice().map(s=>String(s).trim()).sort() : [],
      keywords: Array.isArray(card.keywords) ? card.keywords.slice().map(s=>String(s).trim()).sort() : [],
      cost: card.cost == null ? null : Number(card.cost),
      power: card.power == null ? null : Number(card.power),
      health: card.health == null ? null : Number(card.health),
      color: card.color || 'Colorless',
      type: card.type || 'Unit',
      dice: card.dice == null ? null : String(card.dice).trim(),
      manaDice: card.manaDice == null ? null : String(card.manaDice).trim(),
      flipCondition: card.flipCondition == null ? null : String(card.flipCondition).trim(),
      flipText: card.flipText == null ? null : String(card.flipText).trim(),
      spellSpeed: card.spellSpeed == null ? null : String(card.spellSpeed).trim(),
      spellSubtype: card.spellSubtype == null ? null : String(card.spellSubtype).trim()
    };
    return JSON.stringify(obj);
  }

  function dedupeExactDuplicates(){
    if(!cards || cards.length === 0){
      alert('No cards to dedupe.');
      return;
    }
    const seen = new Map();
    const unique = [];
    let removed = 0;
    for(const c of cards){
      const sig = cardSignature(c);
      if(!seen.has(sig)){
        seen.set(sig, c.id);
        unique.push(c);
      } else {
        removed++;
      }
    }
    if(removed === 0){
      alert('No duplicate cards found.');
      return;
    }
    cards = unique;
    saveAll();
    alert('Removed ' + removed + ' duplicate card' + (removed === 1 ? '' : 's') + '.');
  }

  function renderList(){
    const q = searchInput.value.trim().toLowerCase();
    let filtered = cards.filter(c=>{
      if(activeColor !== 'All' && c.color !== activeColor) return false;
      if(activeType !== 'All' && c.type !== activeType) return false;
      if(activeSpellSubtype !== 'All'){
        // only apply when filtering spells; non-spell items pass through
        if(c.type === 'Spell'){
          if((c.spellSubtype || 'Normal') !== activeSpellSubtype) return false;
        }
      }
      if(!q) return true;
      if(c.name && c.name.toLowerCase().includes(q)) return true;
      if((c.tags||[]).some(t=>t.toLowerCase().includes(q))) return true;
      if((c.keywords||[]).some(k=>k.toLowerCase().includes(q))) return true;
      if((c.type||'').toLowerCase().includes(q)) return true;
      return (c.text||'').toLowerCase().includes(q);
    });

    const sortBy = sortSelect.value;
    if(sortBy === 'name'){
      filtered.sort((a,b)=>a.name.localeCompare(b.name));
    } else if(sortBy === 'cost'){
      filtered.sort((a,b)=> (a.cost||0) - (b.cost||0));
    } else {
      filtered.sort((a,b)=> b.updated - a.updated);
    }

    cardList.innerHTML = '';
    if(filtered.length === 0){
      empty.style.display = 'block';
      return;
    }
    empty.style.display = 'none';

    for(const c of filtered){
      const div = document.createElement('div');
      div.className = 'cardItem';
      const header = document.createElement('div');
      header.className = 'cardHeader';
      const title = document.createElement('div');
      let costText = '';
      if(c.type === 'Hero'){
        costText = `Dice ${escapeHtml(c.dice || '-')}`;
      } else if(c.type === 'Spell'){
        costText = `Cost ${c.cost == null ? '-' : c.cost}`;
      } else if(c.type === 'Weapon'){
        costText = '';
      } else {
        costText = `Cost ${c.cost == null ? '-' : c.cost}`;
      }
      title.innerHTML = `<div class="cardTitle">${escapeHtml(c.name)}</div><div class="meta">${escapeHtml(c.color)} • ${escapeHtml(c.type || 'Unit')}${c.type === 'Spell' && c.spellSubtype ? ' • ' + escapeHtml(c.spellSubtype + ' Spell') : ''}${costText ? ' • ' + escapeHtml(costText) : ''}</div>`;
      header.appendChild(title);
      div.appendChild(header);

      const body = document.createElement('div');
      body.innerHTML = `<div style="font-size:13px;color:var(--muted);margin-bottom:8px">${escapeHtml(c.text || '')}</div>`;
      div.appendChild(body);

      // Render tags
      if(c.tags && c.tags.length){
        const tagsWrap = document.createElement('div');
        for(const t of c.tags){
          const sp = document.createElement('span');
          sp.className = 'tag';
          sp.textContent = t;
          tagsWrap.appendChild(sp);
        }
        div.appendChild(tagsWrap);
      }

      // Render keywords (only for Unit and Hero)
      if(c.keywords && c.keywords.length){
        const kwWrap = document.createElement('div');
        kwWrap.style.marginTop = '8px';
        for(const k of c.keywords){
          const sp = document.createElement('span');
          sp.className = 'tag keyword';
          sp.textContent = k;
          kwWrap.appendChild(sp);
        }
        div.appendChild(kwWrap);
      }

      const meta = document.createElement('div');
      meta.style.marginTop = '8px';
      let statsHtml = '';
      if(c.type === 'Spell'){
        statsHtml = `Speed ${escapeHtml(c.spellSpeed || '-')}`;
      } else if(c.type === 'Hero'){
        statsHtml = `P ${c.power == null ? '-' : c.power} • H ${c.health == null ? '-' : c.health}`;
      } else if(c.type === 'Weapon'){
        statsHtml = ''; // weapons don't show P/H/cost
      } else {
        statsHtml = `P ${c.power == null ? '-' : c.power} • H ${c.health == null ? '-' : c.health}`;
      }
      let flipHtml = '';
      if(c.type === 'Hero'){
        flipHtml = ` <span class="typeBadge">Flip: ${escapeHtml(c.flipCondition || '-')}</span>`;
      }
      const subtypeBadge = (c.type === 'Spell' && c.spellSubtype) ? ` <span class="typeBadge">${escapeHtml(c.spellSubtype)} Spell</span>` : '';
      const manaBadge = (c.type === 'Hero' && c.manaDice) ? ` <span class="typeBadge">Mana: ${escapeHtml(c.manaDice)}</span>` : '';
      meta.innerHTML = `<div class="meta">${statsHtml}${subtypeBadge}${flipHtml}${manaBadge}<span class="typeBadge">${escapeHtml(c.type || 'Unit')}</span></div>`;
      div.appendChild(meta);

      const btns = document.createElement('div');
      btns.className = 'cardButtons';
      const edit = document.createElement('button');
      edit.className = 'small edit';
      edit.textContent = 'Edit';
      edit.onclick = ()=> fillForm(c);
      const del = document.createElement('button');
      del.className = 'small delete';
      del.textContent = 'Delete';
      del.onclick = ()=> confirmDeleteCard(c.id);
      btns.appendChild(edit);
      btns.appendChild(del);
      div.appendChild(btns);

      cardList.appendChild(div);
    }
  }

  function confirmDeleteCard(id){
    toDeleteId = id;
    confirmEl.style.display = 'flex';
  }

  cancelDelete.onclick = ()=>{
    toDeleteId = null;
    confirmEl.style.display = 'none';
  };
  confirmDelete.onclick = ()=>{
    if(!toDeleteId) return;
    cards = cards.filter(c=>c.id !== toDeleteId);
    toDeleteId = null;
    confirmEl.style.display = 'none';
    saveAll();
  };

  saveBtn.addEventListener('click', addOrUpdate);
  clearBtn.addEventListener('click', clearForm);

  // Export: download JSON file
  exportBtn.addEventListener('click', ()=>{
    try{
      const out = JSON.stringify(cards, null, 2);
      const blob = new Blob([out], {type: 'application/json'});
      const ts = new Date();
      const pad = n=>String(n).padStart(2,'0');
      const fname = `tcg_cards_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.json`;
      if(window.navigator && window.navigator.msSaveOrOpenBlob){
        window.navigator.msSaveOrOpenBlob(blob, fname);
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=> URL.revokeObjectURL(url), 1000);
      }
    }catch(e){
      console.error(e);
      alert('Failed to export JSON.');
    }
  });

  // Import file handling
  importBtn.addEventListener('click', ()=> {
    if(!importFile.files || importFile.files.length === 0){
      alert('Please select a JSON file to import.');
      return;
    }
    const file = importFile.files[0];
    const reader = new FileReader();
    reader.onload = function(ev){
      try{
        const parsed = JSON.parse(ev.target.result);
        const arr = Array.isArray(parsed) ? parsed : (parsed.cards || null);
        if(!Array.isArray(arr)){
          alert('JSON does not contain an array of cards.');
          return;
        }
        for(const it of arr){
          if(!it.id) it.id = uid();
          it.updated = Date.now();
          if(!it.type) it.type = 'Unit';
          if(!it.color) it.color = 'Colorless';
          if(!Array.isArray(it.tags)) it.tags = [];
          if(!Array.isArray(it.keywords)) it.keywords = [];
          if(it.type === 'Weapon'){
            it.cost = null;
            it.power = null;
            it.health = null;
          }
          // ensure spellSubtype exists for spells
          if(it.type === 'Spell' && !it.spellSubtype) it.spellSubtype = 'Normal';
        }
        cards = arr.concat(cards);
        saveAll();
        alert('Imported ' + arr.length + ' cards.');
      }catch(e){
        console.error(e);
        alert('Failed to parse JSON file.');
      }
    };
    reader.onerror = function(){
      alert('Failed to read file.');
    };
    reader.readAsText(file, 'utf-8');
    importFile.value = '';
  });

  // Remove exact duplicates button
  removeDupesBtn.addEventListener('click', dedupeExactDuplicates);

  searchInput.addEventListener('input', renderList);
  sortSelect.addEventListener('change', renderList);

  colorFilters.addEventListener('click', (e)=>{
    const chip = e.target.closest('.chip');
    if(!chip) return;
    Array.from(colorFilters.querySelectorAll('.chip')).forEach(el=>el.classList.remove('active'));
    chip.classList.add('active');
    activeColor = chip.dataset.color || 'All';
    renderList();
  });

  // Type filter click handler
  typeFilters.addEventListener('click', (e)=>{
    const chip = e.target.closest('.chip');
    if(!chip) return;
    Array.from(typeFilters.querySelectorAll('.chip')).forEach(el=>el.classList.remove('active'));
    chip.classList.add('active');
    activeType = chip.dataset.type || 'All';
    renderList();
  });

  // Spell subtype filter handler
  spellSubtypeFilters.addEventListener('click', (e)=>{
    const chip = e.target.closest('.chip');
    if(!chip) return;
    Array.from(spellSubtypeFilters.querySelectorAll('.chip')).forEach(el=>el.classList.remove('active'));
    chip.classList.add('active');
    activeSpellSubtype = chip.dataset.spell || 'All';
    renderList();
  });

  formEls.type.addEventListener('change', updateVisibleFields);

  function escapeHtml(s){
    if(!s && s !== 0) return '';
    return String(s).replace(/[&<>"']/g, function(m){
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
    });
  }

  // initial state
  updateVisibleFields();
  renderList();

  window.addEventListener('keydown', function(e){
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's'){
      e.preventDefault();
      addOrUpdate();
    }
  });

  window.TCGCardApp = {
    getAll: ()=>cards.slice(),
    importJson: function(json){
      try{
        const arr = typeof json === 'string' ? JSON.parse(json) : json;
        if(!Array.isArray(arr)) throw new Error('Expected array');
        for(const it of arr){
          if(!it.id) it.id = uid();
          it.updated = Date.now();
          if(!it.type) it.type = 'Unit';
          if(!it.color) it.color = 'Colorless';
          if(!Array.isArray(it.tags)) it.tags = [];
          if(!Array.isArray(it.keywords)) it.keywords = [];
          if(it.type === 'Weapon'){
            it.cost = null;
            it.power = null;
            it.health = null;
          }
          if(it.type === 'Spell' && !it.spellSubtype) it.spellSubtype = 'Normal';
        }
        cards = arr.concat(cards);
        saveAll();
        return true;
      }catch(e){
        console.error(e);
        return false;
      }
    }
  };

})();
</script>
</body>
</html>
```
